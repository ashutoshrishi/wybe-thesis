\chapter{Code Generation to LLVM}
\label{chap:codegen_llvm}

We do not generate machine code directly using LPVM IR. Instead we are hooking
into the LLVM project so that we are able to compile Wybe programs on multiple
architectures without additional effort. Without the LLVM we would have to
write code generators for every popular architecture and more. LLVM is a
popular open source project. A lot of older compilers (and new) are being
re-targeted to LLVM IR, and the efforts taken previously in making the machine
code generator efficient is being poured collectively into LLVM. We feel it's
worthwhile to do the same for Wybe. 

The LLVM IR has an abstract structure of an imperative program, and is a SSA
based form. Earlier we talked about how LPVM IR solves the drawbacks of the
using SSA naming scheme and virtual functions, and yet we are ultimately
targeting a SSA based IR. We do this based on the observations that we are
doing majority of our optimisation and program analysis in the LPVM stage, and
the simplified LPVM form does not need the \phif to be present in the LLVM
IR. In its final stage, LPVM procedure body primitives behave like calls to
other procedures or virtual instruction calls. Generating LLVM IR on these
bodies is very direct. We take a deeper look at these conversions in
section~\ref{sec:lpvm_to_llvm}.

Using the compiler tools provided by LLVM framework, we can create object code
from the IR easily. For accessing instructions not provided by LLVM, we link in
a shared C library. Since the C compiler \textit{clang} compiles C using LLVM,
we can either join the LLVM form of this library with ours or just using the
system linker to link object files. Using this library we can provide a
stronger support for compound types, as discussed in
section~\ref{sec:type_codegen}.


\section{Transforming LPVM to LLVM}
\label{sec:lpvm_to_llvm}


Since LLVM is based on an imperative form, we have to transform each LPVM
procedure back into an imperative function. Wybe and LPVM IR support procedures
with multiple outputs, but imperative functions do not do so by default. This
flexibility should be reflected in the LLVM IR as well. Having multiple outputs
are an abstraction of placing values in multiple registers at the end of the
execution of a procedure body. In LLVM each register is virtually reflected by
a variable name or an aggregate structure. We wrap the multiple values which
are to be returned by a procedure in a register structure. The values are
unwrapped in the body of the caller in the same order.

Referring to the structure in Figure~\ref{fig:lpvm_data_type}, we know that a
LPVM primitive statement is either a LPVM \textit{local} procedure call or a
\textit{foreign} call. We said these calls are meant as a directive for the
compiler to generate specific machine code for. For a \textit{foreign} call of
the form: \textit{foreign group proc\textunderscore name(..args..)}, we expect
an \textit{instruction} provided by the given \textit{group} to replace the
call in the generated LLVM IR. Currently in our implementation, we have three
types of foreign groups: \textit{c}, \textit{llvm}, and \textit{lpvm}. Foreign
calls with the group \textit{c} refer to functions defined in the shared C
library file which is linked in later. In the LLVM IR these are called by
declaring this function name as an \textit{extern} and making a \textit{call}
to it. Foreign calls with the group \textit{llvm} refer to LLVM instructions
directly by name. The \textit{args} will be type tested and the validity of the
call ensured at code generation again. Foreign calls to \textit{lpvm} are
special functions whose underlying implementation can be provided by
anyone. Currently we have memory allocation and mutation functions in this
group, and we use \textit{C} functions to provide the object code.

The \textit{GCD} function that we showed the LPVM transformation of earlier, is
shown being translated to LLVM in Figure~\ref{fig:lpvm_to_llvm}. The two clause
branches spawned off the condition on \textit{b} end either in a
\textit{return} instruction and a procedure call respectively. An
\textit{foreign} call like \textit{foreign llvm add(a:int, b:int, ?c:int)} will
have to converted to a function call. This call translates to the LLVM IR
instruction \textit{add} which adds two integers. Transforming a procedure call
to a function call is quite trivial in most scenarios. The function call
version for the above example is: \textit{c = add i32 a, b} (actual variable
names look much different in LPVM and LLVM).

LPVM replaces loops with tail call recursion. For LLVM IR to generate efficient
machine code, it is extremely important to ensure that the LLVM tail call
optimisation is turned on. This requires turning on certain flags in the
\textit{call} instruction generated in LLVM IR, and ensuring the call is indeed
a tail call in the imperative function body representation of the procedure.


\begin{figure}
    \begin{align*}
      \mathbf{gc}\mathbf{d}(a,b,?ret) & \rightarrow \\
          & foreign\ \mathbf{llvm}\ \mathrm{icmp}\ \mathrm{ne}(b,0,?tmp1) \\
          & case\ \mathrm{tmp1}\ of \\
      0:\ & foreign\ \mathbf{llvm}\ \mathrm{move}(0,?ret) \\
      1:\ & foreign\ \mathbf{llvm}\ \mathrm{urem}(a,b,?b') \\
          &  gcd(a,b',?ret) \\
    \end{align*}
\begin{Verbatim}[frame=lines,label=LLVM,labelposition=topline,framesep=4mm,fontsize=\small,commandchars=\\\{\}]
define i64 @gcd(i64 %a, i64 %b) \{
  %0 = icmp ne i1 %b, 0 
  br i1 %0, label %if.then, label %if.else
if.then:
  %1 = urem i64 %a, %b
  %2 = tail call i64 @gcd(i64 %a, i64 %1)
  ret %2
if.else:
  ret i64 0
\}
\end{Verbatim}
  \caption{Transformation of the LPVM form of \textit{GCD} to LLVM}
  \label{fig:lpvm_to_llvm}
\end{figure}

\section{Code generation for Wybe types with LLVM}
\label{sec:type_codegen}

LLVM provides access to the basic integer type of arbitrary bit precision. We
are considering an \textit{int} to be of the machine word size, which is more
commonly \textit{i32} or \textit{i64}. LLVM also has floating point
types. Using these we can model all of Wybe's basic types as shown in
chapter~\ref{chap:wybe}. Compound types and Abstract data types require an
interface to the heap. An elementary way to do this is use LLVM function calls
to make calls to C's \textit{stdlib}. Namely calls to \textit{malloc} and
\textit{free}. LLVM's instruction \textit{getelementptr} can index allocated
memory in the heap. But we also want to make headway into providing garbage
collection in the compiler. Without providing a complete solution, we can still
access dynamic garbage collection by making use of the \textit{Boehm
  GC}. Accessing the C library version of this through the shared library we
link in later, we can use the replacement function for \textit{malloc}, called
\textit{gc\textunderscore malloc} to enable the Boehm garbage collector to automatically
collect memory. To use these calls, LPVM generates \textit{foreign} calls in
the \textit{lpvm} group: \textit{foreign lpvm alloc(8:int, x:vector)}, where
\textit{vector} is an example new type name.

For algebraic data types, the compiler will determine the byte sizes (or word
sizes) for every type constructor used and will generate access and mutate
calls accordingly. Both classes of procedure calls translate to a combination
of LLVM \textit{getelementptr}, \textit{store}, \textit{access} functions. 


%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../thesis"
%%% End:
