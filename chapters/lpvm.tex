\chapter{Implementation of LPVM}

The actual implementation of the LPVM structure differs a bit from the abstract
structure proposed in \cite{lpvm2015}. For a guard goal, the abstract
representation results in having two clauses with the same initial sequence of
goals up until complimentary guard goals. In the implementation however, to
avoid duplication, there is only one clause generated. The basic clause body is
a sequence of goals barring a guard goal. At the guard goal a fork is created
which contains the fork condition, and a list of basic subsequent clause
bodies, each for an outcome of the condition. A binary condition will have two
basic bodies in the fork list. This is similar to basic block branching in SSA,
however the diverging branches don't need to converge in a body and hence there
will be no need for \textit{phi} like functions.

In a way LPVM procedures or predicates are polymorphic since a call to them
will execute any one of the clauses under them. There can be a \textit{Clause}
for different modes of the procedure parameters. For example, the procedure
\( - \) can have clauses \( -(a, b, ?c) \) and \( -(a, ?b, c) \), marking
different operand positions as outputs. Even though each of the clause
functions in a single mode, a procedure can be made to exhibit multiple modes
of a logic programming language. This construct is very similar to the
polymorphism Wybe has to offer, and is such this construct directly enables it
it. 


\begin{figure}
  \centering
  \begin{tabular}{l@{\hskip 1in} l}
    \( x0 = x1 + x3 \)              & \( wybe.int.+(x1, x3, ?x0) \) \\
    \( if\ (x0 > 0)\ left\ right \) & \( wybe.int.>(x0,\ 0,\ ?tmp1) \) \\
                                    & \( case\ tmp1\ of \) \\
                                    & \( 0:\ left.. \) \\
                                    & \( 1:\ right.. \) \\
    

  \end{tabular}
  \\
  \caption{SSA statement and their equivalent LPVM goals}
\end{figure}

\begin{figure}
  \centering
  \begin{tabular}{r c l}
    \( Proc \)   & \( \rightarrow \) & \( Clause* \) \\
    \( Clause \) & \( \rightarrow \) & \( Proto\ Body \) \\
    \( Proto \)  & \( \rightarrow \) & \( Name\ Param* \) \\
    \( Param \)  & \( \rightarrow \) & \( Name\ Type\ Flow \) \\
    \( Body \)   & \( \rightarrow \) & \( Prim*\ Fork \) \\
    \( Prim \)   & \( \rightarrow \) & \( PrimCall\ |\ PrimForeign \) \\
    \( Fork \)   & \( \rightarrow \) & \( Var\ Body* \) \\
                 & \( \rvert \)      & \( NoFork \) \\
  \end{tabular}
  \caption{LPVM Implementation Data Type}
  \label{fig:lpvm_data_type}
\end{figure}


\noindent\begin{figure}
  \vskip 1em
  \noindent\begin{minipage}{.4\textwidth}
    \begin{Verbatim}[frame=single,framesep=2mm,commandchars=\\\{\}]
\textbf{do} a
   \textbf{if} b: Break
   \textbf{else}: c
\textbf{end}
d
    \end{Verbatim}
  \end{minipage}
  \noindent\begin{minipage}{.5\textwidth}
    \begin{tabular}{r c l}
     $ \mathbf{proc}\ next1\ $ & $ \rightarrow $ & $ a\ gen1\ \mathbf{end} $\\
     $ \mathbf{proc}\ gen1\  $ & $ \rightarrow $ & $ \mathbf{guard}\ b\ 1:
                                                   break1\ \mathbf{end} $ \\
                               & $ \rvert $      & $ \mathbf{guard}\ b\ 0:
                                                   gen2\ \mathbf{end} $ \\
     $ \mathbf{proc}\ gen2\ $  & $ \rightarrow $ & $ c\ next1\ \mathbf{end} $ \\
     $ \mathbf{proc}\ break1\ $ & $\rightarrow$ & $ d\ \mathbf{end} $ \\
    \end{tabular}
  \end{minipage}
  \caption{LPVM Procedures generated for an Imperative Loop}
  \label{fig:loop_lpvm}
\end{figure}


The Figure~\ref{fig:lpvm_data_type} shows the algebraic data type used to hold
the LPVM IR. This representation has Wybe sensitive information like Wybe types
and module fields stripped away for easier discussion. In the implemented data
type, the term \textit{Goal} is replaced with \textit{Prim}, for
primitive. These primitive statements are meant to reflect source and target
code semantics. They are just procedure calls and the only semantic information
they contain are the procedure name and the signature. These can be used to
refer to source language procedures or machine code (or LLVM) instructions just
as easily. Local calls look like: \textit{factorial(tmp\$10: int, ?tmp\$3:
  int)}, and foreign calls look like: \textit{foreign llvm mul(tmp\$2: int, 9:
  int, ?tmp\$3: int)}. The compiler will decide what code to generate for a
given \textit{Prim}.

Conditional statements or goals partition a clause body as discussed above. But
a loop conditional can't just do that as it would require a a jump back into a
previous body. LPVM does not have these, and in fact these are part of the SSA
drawbacks it wants to avoid. Loops are un-branched by generating new procedures
which are involved in recursive calls. The calls are tail calls and hence the
code generation will have to ensure tail call optimisation is
enabled. A procedure will be generated for the loop body primitives which ends
up calling itself recursively, and another generated procedure will contain the
body which comes after the loop. The clause body that the loop was a statement
in originally will end with a call to the former. There would also be a
breaking conditional call to the latter.

If we consider \textit{a}, \textit{b}, \textit{c}, \textit{d} as a
representation for one or more body statements or primitives, a looping
construct looks like \( \mathbf{do}\ a\ b\ \mathbf{end}\ c\ d\). The two
generated procedures for it will can be
\( \mathbf{next1:}\ a\ b\ next1\ \mathbf{end} \) and
\( \mathbf{break1:}\ c\ d\ \mathbf{end} \). A more compound example with
conditional breaking is shown in Figure~\ref{fig:loop_lpvm}. The guard goal(s)
\textit{b} decides whether to exit the loop or not, and \textit{c} represents
the remaining body of the loop after the condition. The conditional inside the
loop split the generated procedure \textit{next1} into \textit{gen1} and
\textit{gen2}. As shown above, in the implementation the two clauses of
\textit{gen2} will be present in a \textit{Fork} based on the value of \textit{b}.



