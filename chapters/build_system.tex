\chapter{Wybemk, Compiler and Build System}

Wybemk is the incremental compiler and a Make utility combined together in one
executable for Wybe source code. It is modelled after the GNU Make utility, but
doesn't need an explicit Makefile to make Wybe source files. The Wybemk
compiler just needs the name of a target to build, and it will infer the
building and linking order. Targets include architecture dependant relocatable
object files, LLVM bitcode files, or a final linked executable. The object
files and bitcode files that Wybemk builds are a little different than what
other utilities create. They have embedded information that assists the future
compilation processes in being incremental. It is this embedding that allows
Wybemk to be an incremental and work-saving compiler.

The elementary work saving features are very similar to what the GNU Make does.
It does not want to rebuild any object file which is already built and is newer
than its corresponding source file. But by doing so, the LPVM form and analysis
for that module is also skipped. This is acceptable for only intra module
optimisations, since the final optimised object code will be the same. But we
might be missing a lot of inter module optimisation opportunities and LPVM
inlining that other dependant modules can reap benefits from. Object files
store a symbol table which will list all the callable function names in
it. This is what the \textit{linker} uses to resolve extern calls during
linking. The body of these functions are stored in object code form. We can't
make a decision on inlining these functions into another module from this. It
would be nice to have the LPVM form of all the modules participating in a
compilation process for these optimisation decisions. We want to store LPVM
analysis information in the object files so that when they are not going to be
re-compiled, we can at least pull in the LPVM form of that module in the
compilation pipeline.

The limited structure of LPVM makes serialising and embedding its byte
structure into a object file byte string easy and feasibile. We could have also
stored the parse tree, but a parse tree has a wider form and is redundant with
the source code. With storing the parse tree we are only skipping the work the
parser does and would have to redo all the LPVM transformation and
analysis. This would be more work. The simple yet highly informational form of
LPVM makes it an ideal structure to pass around.


Why object files though? An object files' structure is architecture dependant
and requires different efforts for storing and loading information for each
architecture. This would put a constraint on the number of architectures that
Wybemk can operate on eventhough with LLVM it should be able to possibly
generate code for those architectures. However object files are a common
container for relocatable machine code. Most compilers traditionally build a
object file for the linker to link. Currently Wybemk does not want to reinvent
that format and we would like our incrementality features to work in tandem
with the common choices. Apart from object files however, the Wybemk compiler
can do the same embedding with LLVM bitcode files. LLVM bitcode files can be
treated as architecture neutral, and since we use a LLVM compiler as a final
stage, we can use bitcode files as a replacement for architecture dependant
object files too. 


\section{Storing structures in Object files}

Object files store relocatable object code which is the compiled code generated
by the LLVM compiler in the wybe compiler. Even though different architectures
have their own specification of the object file format, they are modelled
around the same basic structure. Object files defines segments, which are
mapped as memory segments during linking and loading. A special segment called
\textit{TEXT} usually contains the instructions. An object file also lists the
symbols defined in it, which is useful for the linker to resolve external
function calls from another module being linked. Avoiding all the common
segment names, it is possible to add new segments to the object file (at the
correct byte offset), which do not get mapped to memory. These are zero address
segments. Using such such segment we can attempt storage of some useful
serialised meta-data in the object file. 

Our current implementation has the functionality to parse and embed information
in \macho object files. The \macho file format is the Application Binary
Interface (ABI) format that the OS X operating system uses for its object
files. An ABI describes the byte ordering and their meaning for the operating
system in this case. 

\subsection{Mach-O Object File Format}

The first 32 bits or 4 bytes are considered to be the magic number if read in
little endian format. The magic number constant determines what kind of ABI the
rest of the bytes of the file follow and their ordering. On OS X we can have 32
bit and 64 bit \macho object files and Universal binaries. Universal binaries
or Fat archives contain more than one object file. Wybemk is interested in
\macho object files.

% TODO Decide what to actually write here
% TODO Things to mention: 
% o What we are actually serialising
% o Space it takes
% o Things it affects : none
% o Bitcode files

\section{Incremental Compilation}

Wybe, as a programming language, wants to be useful for large scale
projects. Thus, it wants its compilation process to be as effecient as
possible. In larger projects, a large number of modules are involved in a
single build. Doing incremental builds would involve smaller changes being
added for every fresh build. Having all the modules compile again is a waste of
time. 

Wybemk is incremental at a lot of levels. The goal is to identify key stages of
a compilation process which can act as save and restore points. The saving is
done in object files (or bitcode files) as shown above. The decision to restore
has to be a careful one, as a false positive would result in a completely wrong
build. There should be no margin for these kinds of errors to exist if this
compiler is to be used in production builds. There is also a requirement of
incrementality without losing the benefits of LPVM optimisations. With these
constraints, Wybemk has two incremental and work saving approaches: Module
level reloading, and storing hashes of key compilation stages. 


\subsection{Module level reloading}

Wybemk compiler behaves like GNU Make but it does not depend on Makefiles. It
infers the module dependancy graph and builds everything accordingly. It should
also link in standard libraries and external foreign libraries wherever
needed. Inferring the dependancy graph is done through parsing the top level
\textit{use module} statements. During compilation LPVM representation of each
module in the graph is built. For modules who have a newer object file, this
representation will be stored in a serialised form and has to be
\textit{reloaded} into the pipeline. This keeps the optimisations going and
allows other modules to inline functions or procedures from that module.

For example the \textit{int} module in the Wybe standard library module
(Figure~\ref{fig:wybe_int}) mostly has one line procedures and functions
(simple arithmetic operators pointing to LLVM instructions). That is, their
body is a single procedure call. Instances of calls to \textit{proc +} can be
replaced with the body proc call instead. And this is what actually happens
when the standard library object file is \textit{loaded} by the Wybemk
compiler. Inlining at LPVM level provides these small but essential benefits.


\subsection{Incrementality through Hashes}




