\chapter{Wybe programming Language}
\label{chap:wybe}



% Figure for showing the INT module
\begin{figure}

\textit{public type} \textbf{int} \textit{is} \textbf{i64}

\begin{itemize}[label={}]
\setlength\itemsep{0em}
\item
\textit{public func} 
\textbf{+}(x: int, y: int) : int = foreign llvm add(x,y)

\item  
\textit{public proc} 
\textbf{+}(?x: int, y: int, z: int) ?x = foreign llvm sub(z,y) 
\textit{end}

\item 
\textit{public proc} 
\textbf{+}(x: int, ?y: int, z: int) ?y = foreign llvm sub(z,x) 
\textit{end}

\item 
\textit{public func} 
\textbf{=}(x: int, y: int) : bool = foreign llvm icmp eq(x,y)
\end{itemize}

\textit{end} \\

\caption{Sample of the wybe.int module from Wybe standard library}
\label{fig:wybe_int}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



% Figure for showing the bool type
\begin{figure}
\vskip 2em
\textit{public type} \textbf{bool} = 
\textit{public} \textbf{false} \verb!|! \textbf{true}
\begin{itemize}[label={}]
\setlength\itemsep{0em}

    
\item
\textit{public func} \textbf{=}(x: bool, y: bool) : bool = 
\textit{foreign} \textit{llvm} icmp eq(x,y)

\item
\textit{public func} \textbf{/=}(x: bool, y: bool) : bool = 
\textit{foreign} \textit{llvm} icmp ne(x,y)
\end{itemize}
\textit{end}

\caption{Bool type as an Algebraic Data Type from the Wybe standard library}
\label{fig:wybe_bool}
\end{figure}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%



Wybe is a new multi-paradigm programming language, featuring both imperative
and declarative constructs. At the top level it contains both functions and
procedures. A function header specifies the inputs and their types, and the
output expression type. The body of the function will be an expression
evaluating to a value of that specified out type. Whereas a procedure header
species its inputs and outputs (along with their types), and any mutable or
external resource it works with (like IO). Its body will contain sequential
statements which build those outputs from the inputs. There is no return
statement, as at the end of the procedure body the specified outputs will be
returned. In a way, a procedure header lists the parameters which will be used
in its body, and fixes the flow mode (input flow or output flow) for each of
them.

Wybe is statically typed with a strong preference for interface integrity, for
which a function or procedure header should define all it's input and output
types, along with any mutable resources that will be affected. By forcing the
information flow to be explicit, Wybe makes it easy to determine the purity of
the function just by looking at a function or procedure prototype. There is
also no requirement for an interface or header file. Variables in Wybe can be
adorned to explicitly define their direction of information flow. A variable
can flow in (x), flow out (?x), or both ways (!x). The Wybe model of explicit
information flow is quite similar to the LPVM predicates, making LPVM a good
fit for this language. 

With Wybe, a module is equivalent to a wybe source file. The module name is
same as the source file without the extension. The module's interface consists
of the public functions and procedures in the module. There is also a separate
syntax to declare sub-modules inside the full file module. Sub-module names are
qualified with the outer modules' name. For example a module \textit{A.B.C} is
the sub-module of \textit{A.B}, which is a sub-module of \textit{A}, which is
the module of the source file \textit{A.wybe}. Defining new types also creates
a new sub-module. All dependencies of a module can be inferred through the top
level \textit{use module} statements in the source file.

Types in Wybe are simply modules. Standard Wybe considers {int},
\textit{float}, \textit{char}, \textit{string} as primitive types. In reality
these are just types provided by the Wybe standard library module, which can be
replaced with any other flavour of a standard library. Defining basic types
requires just specifying its memory layout (in terms of word sizes) and
providing procedures or functions to interact with the basic type. A sample
from the \textit{wybe.int} type module is shown in Figure~\ref{fig:wybe_int}. This
type definition is in the source file \textit{wybe.wybe}, making \textit{int} a sub-module
of the module \textit{wybe}. This \textit{int} type sets the size of its
members to be \textit{i64}, a syntax borrowed from LLVM, occupying 64 bits. 

More compound types can be defined in terms of basic types or other compound
types. Wybe has \textit{algebraic data types}. The \textit{bool} type can in
this way with two type constructors, as shown in
Figure~\ref{fig:wybe_bool}. The compiler will infer the storage for members of
this type. 


Procedures (and even functions) in Wybe can be polymorphic. Multiple Wybe
procedures can have the same name but with different paramter types and
modes. For example, a procedure to add two numbers can have the following
prototypes: \textit{add(x, y, ?z)}, \textit{add(x, ?y, z)}, \textit{add(?x, y,
  z)}. The call \textit{add(3, ?t, 5)} will evaluate \textit{t} to be
\textit{2}. This selection is done in the Type checking pass during
compilation, which matches calls to the definition with the correct types and
modes.


